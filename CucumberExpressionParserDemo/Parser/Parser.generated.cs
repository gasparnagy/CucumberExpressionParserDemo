// ------------------------------------------------------------------------------
//  <auto-generated>
//      This code was generated by Berp (http://https://github.com/gasparnagy/berp/).
// 
//      Changes to this file may cause incorrect behavior and will be lost if
//      the code is regenerated.
//  </auto-generated>
// ------------------------------------------------------------------------------
#region Designer generated code
#pragma warning disable
using System;
using System.Collections.Generic;
namespace Cucumber
{
    public enum TokenType
    {
        None,
        EOF,
        Word,
        Separator,
        Slash,
        LParen,
        RParen,
        LCurl,
        RCurl,
        Other,
    }

    public enum RuleType
    {
        None,
        _EOF, // #EOF
        _Word, // #Word
        _Separator, // #Separator
        _Slash, // #Slash
        _LParen, // #LParen
        _RParen, // #RParen
        _LCurl, // #LCurl
        _RCurl, // #RCurl
        _Other, // #Other
        CucumberExpression, // CucumberExpression! := (WordLike | Optional | Parameter | #Separator)*
        WordLike, // WordLike := (#Word | Alternation)
        Alternation, // Alternation! [#Word-&gt;#Slash] := #Word (#Slash #Word)+
        Optional, // Optional! := #LParen (#Word | #Separator)+ #RParen
        Parameter, // Parameter! := #LCurl #Word #RCurl
    }

    [System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    public partial class CucumberExpressionsParser
    {
        public bool StopAtFirstError { get; set;}

        [System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
        protected class ParserContext
        {
            public ITokenScanner TokenScanner { get; set; }
            public ITokenMatcher TokenMatcher { get; set; }
            public IAstBuilder Builder { get; set; }
            public Queue<Token> TokenQueue { get; set; }
            public List<ParserException> Errors { get; set; }
        }

        public Cucumber.Ast.CucumberExpression Parse(ITokenScanner tokenScanner)
        {
            return Parse(tokenScanner, new TokenMatcher(), new AstBuilder());
        }

        public Cucumber.Ast.CucumberExpression Parse(ITokenScanner tokenScanner, ITokenMatcher tokenMatcher, IAstBuilder astBuilder)
        {
            var context = new ParserContext
            {
                TokenScanner = tokenScanner,
                TokenMatcher = tokenMatcher,
                Builder = astBuilder,
                TokenQueue = new Queue<Token>(),
                Errors = new List<ParserException>()
            };

            StartRule(context, RuleType.CucumberExpression);
            int state = 0;
            Token token;
            do
            {
                token = ReadToken(context);
                state = MatchToken(state, token, context);
            } while(!token.IsEOF);

            EndRule(context, RuleType.CucumberExpression);

            if (context.Errors.Count > 0)
            {
                throw new CompositeParserException(context.Errors.ToArray());
            }

            return GetResult(context);
        }

        private void AddError(ParserContext context, ParserException error)
        {
            context.Errors.Add(error);
            if (context.Errors.Count > 10)
                throw new CompositeParserException(context.Errors.ToArray());
        }

        private void HandleAstError(ParserContext context, Action action)
        {
            HandleExternalError(context, () => { action(); return true; });
        }

        private T HandleExternalError<T>(ParserContext context, Func<T> action, T defaultValue = default(T))
        {
            if (StopAtFirstError)
            {
                return action();
            }

            try
            {
                return action();
            }
            catch (CompositeParserException compositeParserException)
            {
                foreach (var error in compositeParserException.Errors)
                    AddError(context, error);
            }
            catch (ParserException error)
            {
                AddError(context, error);
            }
            return defaultValue;
        }

        void Build(ParserContext context, Token token)
        {
            HandleAstError(context, () => context.Builder.Build(token));
        }

        void StartRule(ParserContext context, RuleType ruleType)
        {
            HandleAstError(context, () => context.Builder.StartRule(ruleType));
        }

        void EndRule(ParserContext context, RuleType ruleType)
        {
            HandleAstError(context, () => context.Builder.EndRule(ruleType));
        }

        Cucumber.Ast.CucumberExpression GetResult(ParserContext context)
        {
            return context.Builder.GetResult();
        }

        Token ReadToken(ParserContext context)
        {
            return context.TokenQueue.Count > 0 ? context.TokenQueue.Dequeue() : context.TokenScanner.Read();
        }


        bool Match_EOF(ParserContext context, Token token)
        {
            return HandleExternalError(context, () => context.TokenMatcher.Match_EOF(token), false); 
        }

        bool Match_Word(ParserContext context, Token token)
        {
            if (token.IsEOF) return false;
            return HandleExternalError(context, () => context.TokenMatcher.Match_Word(token), false); 
        }

        bool Match_Separator(ParserContext context, Token token)
        {
            if (token.IsEOF) return false;
            return HandleExternalError(context, () => context.TokenMatcher.Match_Separator(token), false); 
        }

        bool Match_Slash(ParserContext context, Token token)
        {
            if (token.IsEOF) return false;
            return HandleExternalError(context, () => context.TokenMatcher.Match_Slash(token), false); 
        }

        bool Match_LParen(ParserContext context, Token token)
        {
            if (token.IsEOF) return false;
            return HandleExternalError(context, () => context.TokenMatcher.Match_LParen(token), false); 
        }

        bool Match_RParen(ParserContext context, Token token)
        {
            if (token.IsEOF) return false;
            return HandleExternalError(context, () => context.TokenMatcher.Match_RParen(token), false); 
        }

        bool Match_LCurl(ParserContext context, Token token)
        {
            if (token.IsEOF) return false;
            return HandleExternalError(context, () => context.TokenMatcher.Match_LCurl(token), false); 
        }

        bool Match_RCurl(ParserContext context, Token token)
        {
            if (token.IsEOF) return false;
            return HandleExternalError(context, () => context.TokenMatcher.Match_RCurl(token), false); 
        }

        bool Match_Other(ParserContext context, Token token)
        {
            if (token.IsEOF) return false;
            return HandleExternalError(context, () => context.TokenMatcher.Match_Other(token), false); 
        }

        protected virtual int MatchToken(int state, Token token, ParserContext context)
        {
            int newState;
            switch(state)
            {
                case 0:
                    newState = MatchTokenAt_0(token, context);
                    break;
                case 1:
                    newState = MatchTokenAt_1(token, context);
                    break;
                case 2:
                    newState = MatchTokenAt_2(token, context);
                    break;
                case 3:
                    newState = MatchTokenAt_3(token, context);
                    break;
                case 4:
                    newState = MatchTokenAt_4(token, context);
                    break;
                case 5:
                    newState = MatchTokenAt_5(token, context);
                    break;
                case 6:
                    newState = MatchTokenAt_6(token, context);
                    break;
                case 7:
                    newState = MatchTokenAt_7(token, context);
                    break;
                case 8:
                    newState = MatchTokenAt_8(token, context);
                    break;
                case 9:
                    newState = MatchTokenAt_9(token, context);
                    break;
                default:
                    throw new InvalidOperationException("Unknown state: " + state);
            }
            return newState;
        }

        
        // Start
        int MatchTokenAt_0(Token token, ParserContext context)
        {
            if (Match_EOF(context, token))
            {
                Build(context, token);
                return 10;
            }
            if (Match_Word(context, token))
            {
                if (LookAhead_0(context, token))
                {
                StartRule(context, RuleType.Alternation);
                Build(context, token);
                return 1;
                }
            }
            if (Match_Word(context, token))
            {
                Build(context, token);
                return 0;
            }
            if (Match_LParen(context, token))
            {
                StartRule(context, RuleType.Optional);
                Build(context, token);
                return 4;
            }
            if (Match_LCurl(context, token))
            {
                StartRule(context, RuleType.Parameter);
                Build(context, token);
                return 7;
            }
            if (Match_Separator(context, token))
            {
                Build(context, token);
                return 0;
            }
            
            const string stateComment = "State: 0 - Start";
            token.Detach();
            var expectedTokens = new string[] {"#EOF", "#Word", "#LParen", "#LCurl", "#Separator"};
            var error = token.IsEOF ? (ParserException)new UnexpectedEOFException(token, expectedTokens, stateComment) 
                : new UnexpectedTokenException(token, expectedTokens, stateComment);
            if (StopAtFirstError)
                throw error;
            
            AddError(context, error);
            return 0;

        }
        
        
        // CucumberExpression:0>__alt0:0>WordLike:0>__alt1:1>Alternation:0>#Word:0
        int MatchTokenAt_1(Token token, ParserContext context)
        {
            if (Match_Slash(context, token))
            {
                Build(context, token);
                return 2;
            }
            
            const string stateComment = "State: 1 - CucumberExpression:0>__alt0:0>WordLike:0>__alt1:1>Alternation:0>#Word:0";
            token.Detach();
            var expectedTokens = new string[] {"#Slash"};
            var error = token.IsEOF ? (ParserException)new UnexpectedEOFException(token, expectedTokens, stateComment) 
                : new UnexpectedTokenException(token, expectedTokens, stateComment);
            if (StopAtFirstError)
                throw error;
            
            AddError(context, error);
            return 1;

        }
        
        
        // CucumberExpression:0>__alt0:0>WordLike:0>__alt1:1>Alternation:1>__grp2:0>#Slash:0
        int MatchTokenAt_2(Token token, ParserContext context)
        {
            if (Match_Word(context, token))
            {
                Build(context, token);
                return 3;
            }
            
            const string stateComment = "State: 2 - CucumberExpression:0>__alt0:0>WordLike:0>__alt1:1>Alternation:1>__grp2:0>#Slash:0";
            token.Detach();
            var expectedTokens = new string[] {"#Word"};
            var error = token.IsEOF ? (ParserException)new UnexpectedEOFException(token, expectedTokens, stateComment) 
                : new UnexpectedTokenException(token, expectedTokens, stateComment);
            if (StopAtFirstError)
                throw error;
            
            AddError(context, error);
            return 2;

        }
        
        
        // CucumberExpression:0>__alt0:0>WordLike:0>__alt1:1>Alternation:1>__grp2:1>#Word:0
        int MatchTokenAt_3(Token token, ParserContext context)
        {
            if (Match_EOF(context, token))
            {
                EndRule(context, RuleType.Alternation);
                Build(context, token);
                return 10;
            }
            if (Match_Slash(context, token))
            {
                Build(context, token);
                return 2;
            }
            if (Match_Word(context, token))
            {
                if (LookAhead_0(context, token))
                {
                EndRule(context, RuleType.Alternation);
                StartRule(context, RuleType.Alternation);
                Build(context, token);
                return 1;
                }
            }
            if (Match_Word(context, token))
            {
                EndRule(context, RuleType.Alternation);
                Build(context, token);
                return 0;
            }
            if (Match_LParen(context, token))
            {
                EndRule(context, RuleType.Alternation);
                StartRule(context, RuleType.Optional);
                Build(context, token);
                return 4;
            }
            if (Match_LCurl(context, token))
            {
                EndRule(context, RuleType.Alternation);
                StartRule(context, RuleType.Parameter);
                Build(context, token);
                return 7;
            }
            if (Match_Separator(context, token))
            {
                EndRule(context, RuleType.Alternation);
                Build(context, token);
                return 0;
            }
            
            const string stateComment = "State: 3 - CucumberExpression:0>__alt0:0>WordLike:0>__alt1:1>Alternation:1>__grp2:1>#Word:0";
            token.Detach();
            var expectedTokens = new string[] {"#EOF", "#Slash", "#Word", "#LParen", "#LCurl", "#Separator"};
            var error = token.IsEOF ? (ParserException)new UnexpectedEOFException(token, expectedTokens, stateComment) 
                : new UnexpectedTokenException(token, expectedTokens, stateComment);
            if (StopAtFirstError)
                throw error;
            
            AddError(context, error);
            return 3;

        }
        
        
        // CucumberExpression:0>__alt0:1>Optional:0>#LParen:0
        int MatchTokenAt_4(Token token, ParserContext context)
        {
            if (Match_Word(context, token))
            {
                Build(context, token);
                return 5;
            }
            if (Match_Separator(context, token))
            {
                Build(context, token);
                return 5;
            }
            
            const string stateComment = "State: 4 - CucumberExpression:0>__alt0:1>Optional:0>#LParen:0";
            token.Detach();
            var expectedTokens = new string[] {"#Word", "#Separator"};
            var error = token.IsEOF ? (ParserException)new UnexpectedEOFException(token, expectedTokens, stateComment) 
                : new UnexpectedTokenException(token, expectedTokens, stateComment);
            if (StopAtFirstError)
                throw error;
            
            AddError(context, error);
            return 4;

        }
        
        
        // CucumberExpression:0>__alt0:1>Optional:1>__alt3:0>#Word:0
        int MatchTokenAt_5(Token token, ParserContext context)
        {
            if (Match_Word(context, token))
            {
                Build(context, token);
                return 5;
            }
            if (Match_Separator(context, token))
            {
                Build(context, token);
                return 5;
            }
            if (Match_RParen(context, token))
            {
                Build(context, token);
                return 6;
            }
            
            const string stateComment = "State: 5 - CucumberExpression:0>__alt0:1>Optional:1>__alt3:0>#Word:0";
            token.Detach();
            var expectedTokens = new string[] {"#Word", "#Separator", "#RParen"};
            var error = token.IsEOF ? (ParserException)new UnexpectedEOFException(token, expectedTokens, stateComment) 
                : new UnexpectedTokenException(token, expectedTokens, stateComment);
            if (StopAtFirstError)
                throw error;
            
            AddError(context, error);
            return 5;

        }
        
        
        // CucumberExpression:0>__alt0:1>Optional:3>#RParen:0
        int MatchTokenAt_6(Token token, ParserContext context)
        {
            if (Match_EOF(context, token))
            {
                EndRule(context, RuleType.Optional);
                Build(context, token);
                return 10;
            }
            if (Match_Word(context, token))
            {
                if (LookAhead_0(context, token))
                {
                EndRule(context, RuleType.Optional);
                StartRule(context, RuleType.Alternation);
                Build(context, token);
                return 1;
                }
            }
            if (Match_Word(context, token))
            {
                EndRule(context, RuleType.Optional);
                Build(context, token);
                return 0;
            }
            if (Match_LParen(context, token))
            {
                EndRule(context, RuleType.Optional);
                StartRule(context, RuleType.Optional);
                Build(context, token);
                return 4;
            }
            if (Match_LCurl(context, token))
            {
                EndRule(context, RuleType.Optional);
                StartRule(context, RuleType.Parameter);
                Build(context, token);
                return 7;
            }
            if (Match_Separator(context, token))
            {
                EndRule(context, RuleType.Optional);
                Build(context, token);
                return 0;
            }
            
            const string stateComment = "State: 6 - CucumberExpression:0>__alt0:1>Optional:3>#RParen:0";
            token.Detach();
            var expectedTokens = new string[] {"#EOF", "#Word", "#LParen", "#LCurl", "#Separator"};
            var error = token.IsEOF ? (ParserException)new UnexpectedEOFException(token, expectedTokens, stateComment) 
                : new UnexpectedTokenException(token, expectedTokens, stateComment);
            if (StopAtFirstError)
                throw error;
            
            AddError(context, error);
            return 6;

        }
        
        
        // CucumberExpression:0>__alt0:2>Parameter:0>#LCurl:0
        int MatchTokenAt_7(Token token, ParserContext context)
        {
            if (Match_Word(context, token))
            {
                Build(context, token);
                return 8;
            }
            
            const string stateComment = "State: 7 - CucumberExpression:0>__alt0:2>Parameter:0>#LCurl:0";
            token.Detach();
            var expectedTokens = new string[] {"#Word"};
            var error = token.IsEOF ? (ParserException)new UnexpectedEOFException(token, expectedTokens, stateComment) 
                : new UnexpectedTokenException(token, expectedTokens, stateComment);
            if (StopAtFirstError)
                throw error;
            
            AddError(context, error);
            return 7;

        }
        
        
        // CucumberExpression:0>__alt0:2>Parameter:1>#Word:0
        int MatchTokenAt_8(Token token, ParserContext context)
        {
            if (Match_RCurl(context, token))
            {
                Build(context, token);
                return 9;
            }
            
            const string stateComment = "State: 8 - CucumberExpression:0>__alt0:2>Parameter:1>#Word:0";
            token.Detach();
            var expectedTokens = new string[] {"#RCurl"};
            var error = token.IsEOF ? (ParserException)new UnexpectedEOFException(token, expectedTokens, stateComment) 
                : new UnexpectedTokenException(token, expectedTokens, stateComment);
            if (StopAtFirstError)
                throw error;
            
            AddError(context, error);
            return 8;

        }
        
        
        // CucumberExpression:0>__alt0:2>Parameter:2>#RCurl:0
        int MatchTokenAt_9(Token token, ParserContext context)
        {
            if (Match_EOF(context, token))
            {
                EndRule(context, RuleType.Parameter);
                Build(context, token);
                return 10;
            }
            if (Match_Word(context, token))
            {
                if (LookAhead_0(context, token))
                {
                EndRule(context, RuleType.Parameter);
                StartRule(context, RuleType.Alternation);
                Build(context, token);
                return 1;
                }
            }
            if (Match_Word(context, token))
            {
                EndRule(context, RuleType.Parameter);
                Build(context, token);
                return 0;
            }
            if (Match_LParen(context, token))
            {
                EndRule(context, RuleType.Parameter);
                StartRule(context, RuleType.Optional);
                Build(context, token);
                return 4;
            }
            if (Match_LCurl(context, token))
            {
                EndRule(context, RuleType.Parameter);
                StartRule(context, RuleType.Parameter);
                Build(context, token);
                return 7;
            }
            if (Match_Separator(context, token))
            {
                EndRule(context, RuleType.Parameter);
                Build(context, token);
                return 0;
            }
            
            const string stateComment = "State: 9 - CucumberExpression:0>__alt0:2>Parameter:2>#RCurl:0";
            token.Detach();
            var expectedTokens = new string[] {"#EOF", "#Word", "#LParen", "#LCurl", "#Separator"};
            var error = token.IsEOF ? (ParserException)new UnexpectedEOFException(token, expectedTokens, stateComment) 
                : new UnexpectedTokenException(token, expectedTokens, stateComment);
            if (StopAtFirstError)
                throw error;
            
            AddError(context, error);
            return 9;

        }
        

        
        bool LookAhead_0(ParserContext context, Token currentToken)
        {
            currentToken.Detach();
            Token token;
            var queue = new Queue<Token>();
            bool match = false;
            do
            {
                token = ReadToken(context);
                token.Detach();
                queue.Enqueue(token);

                if (false
                    || Match_Slash(context, token)
                )
                {
                    match = true;
                    break;
                }
            } while (false
                || Match_Word(context, token)
            );
            foreach(var t in queue)
                context.TokenQueue.Enqueue(t);
            return match;
        }
        
    }

    public partial interface IAstBuilder 
    {
        void Build(Token token);
        void StartRule(RuleType ruleType);
        void EndRule(RuleType ruleType);
        Cucumber.Ast.CucumberExpression GetResult();
    }

    public partial interface ITokenScanner 
    {
        Token Read();
    }

    public partial interface ITokenMatcher
    {
        bool Match_EOF(Token token);
        bool Match_Word(Token token);
        bool Match_Separator(Token token);
        bool Match_Slash(Token token);
        bool Match_LParen(Token token);
        bool Match_RParen(Token token);
        bool Match_LCurl(Token token);
        bool Match_RCurl(Token token);
        bool Match_Other(Token token);
    }

    public partial class SimpleTokenMatcher : ITokenMatcher
    {
        public virtual bool Match_EOF(Token token) => token.TokenType == TokenType.EOF;
        public virtual bool Match_Word(Token token) => token.TokenType == TokenType.Word;
        public virtual bool Match_Separator(Token token) => token.TokenType == TokenType.Separator;
        public virtual bool Match_Slash(Token token) => token.TokenType == TokenType.Slash;
        public virtual bool Match_LParen(Token token) => token.TokenType == TokenType.LParen;
        public virtual bool Match_RParen(Token token) => token.TokenType == TokenType.RParen;
        public virtual bool Match_LCurl(Token token) => token.TokenType == TokenType.LCurl;
        public virtual bool Match_RCurl(Token token) => token.TokenType == TokenType.RCurl;
        public virtual bool Match_Other(Token token) => token.TokenType == TokenType.Other;
    }
    
    public partial class TokenMatcher : SimpleTokenMatcher
    {
    }
}
#pragma warning restore
#endregion
